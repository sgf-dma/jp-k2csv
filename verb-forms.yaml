---

# Определение файла (точнее, двух файлов: один - с вопросами, другой - с
# ответами) с одинаковыми ふつう形 формами в вопросе и ответе: словарная форма
# в вопросе соответствует словарной форме в ответе, た-форма в вопросе -
# た-форме в ответе, и тд. Единственное различие будет в том, что в файле с
# вопросами всё (почти) будет записано азбукой, а в файле с ответами -
# иероглифами. Те, читая (или слушая) файл с вопросами, нужно будет понять,
# какой это глагол.
#
# В определениях ниже отступы _имеют_ значение, поэтому их надо строго
# соблюдать. Сдвиг каждого следующего блока - два пробела по сравнению с
# предыдущим.
- name: "futsuu-futsuu"
  # Список определений _пар_ вопрос-ответ, начинается с `questions:`
  questions:
    # Определение одной пары начинается с чёрточки (`-`).
    #
    # Каждый вопрос состоит из списка вопросов (может быть больше одного, см.
    # примеры ниже), определённых в поле `front`, и _одного_ ответа,
    # определённого в поле `back`. Те все вопросы, определённые внутри одной
    # пары, будут иметь _один и тот же_ ответ.
    - front:
        # Определение вопроса должно начинаться с `- line: `, запись `&dictL`
        # позволяет присвоить содержимому этого блока имя `dictL`, чтобы
        # дальше в файле можно было просто писать `*dictL` вместо всего блока
        # ([yaml anchor](http://yaml.org/spec/1.2/spec.html#c-ns-anchor-property)).
        #
        # Здесь будет только один вопрос со словарной формой.
        #
        # _Важно:_ сдвиг этого блока - 4 пробела по сравнению с `- front:`
        # (потому что содержимое этого блока - это содержимое поля `front, а
        # не элемент списка).
        - line: &dictL
          # Здесь в вопросе будет словарная форма. Содержимому этого блока
          # тоже присвоено имя (`dict`, без буквы `L` на конце) для удобства в
          # дальнейшем.
          - vform: &dict
              # В поле `base` указывается базовая форма из таблицы глаголов
              # (см. README), от которой нужно образовать новую.
              #
              # Имена, которые здесь можно использовать (`dictBased` в данном
              # случае), должны быть опеределены в списке `baseForms` в файле
              # `src/Sgf/Jp/Types/VForms.hs` и должны иметь соответствующую им
              # функцию, которая будет генерировать другие формы, основанные
              # на соответствующей основной форме. В этом же файле
              # (`src/Sgf/Jp/Types/VForms.hs`) можно посмотреть все доступные
              # для использования имена базовых форм.
              #
              # _Важно:_ сдвиг блока с `base` и `new` - 4 пробела по сравнению
              # с `- vform:` (по той же причине, что выше).
              base: "dictBased"
              # Какой суффикс добавлять для образования новой формы. В данном
              # случае словарная форма остается без изменения, поэтому
              # добавляем пустую строку.
              new:  ""
      back:
        # Ответ имеет такое же определение, как и вопрос, поэтому, чтобы не
        # переписывать заново, просто используем имя, определённое выше.
        #
        # На данный момент, ответ _всегда_ будет записан иероглифами, кроме
        # случаев, когда в таблице глаголов нету записи иероглифами.  Вопрос
        # же - _всегда_ азбукой, кроме случаев, когда в таблице глаголу
        # присвоен тег `kanji`. Это можно использовать, когда text-to-speech
        # программа неправильно читает запись азбукой (например, в はいる она
        # будет читать は как "ва").
        line: *dictL
    # Определение следующей пары вопрос-ответ.
    #
    # Тк в этом файле каждый вопрос имеет разный ответ: вопрос со словарной
    # формой - ответ со словарной, вопрос с た-формой - ответ с た-формой, и
    # тд, то мы должны определять всё это в разных парах, тк в одной паре
    # ответ для всех вопросов будет одинаковый.
    - front:
        - line: &naiL
          - vform: &nai
              base: "naiBased"
              # Для ない-формы функция, которые генерирует другие основанные
              # на ней формы, убирает суффикс ない. Поэтому сейчас его надо
              # добавить снова, указав в поле `new`, тк нам нужна именно ない
              # форма.
              new:  "ない"
      back:
        line: *naiL
    - front:
        - line: &taL
          - vform: &ta
              base: "teBased"
                # た-форма генерируется из て-формы в таблице глаголов, и
                # функция, которая это делает, сперва убирает て (или で)
                # суффикс. Поэтому, тк нам нужна た-форма, мы должны добавить
                # た (функция сохраняет озвончение, те если て-форма
                # оканчивалась на で, то た будет заменено だ).
              new:  "た"
      back:
        line: *taL
    - front:
        - line: &nakattaL
          - vform: &nakatta
              base: "naiBased"
              # Здесь, в отличие от ない формы выше, на место ない нужно
              # поставить なかった .
              new:  "なかった"
      back:
        line: *nakattaL

# Это определение файла, в котором в вопросе может быть ます-форма или
# словарная форма, а в ответе всегда будут все четыре ふつう形 формы.
- name: "masu_dict-futsuu"
  questions:
    - front:
        # Как было написано выше, одна пара вопрос-ответ может иметь несколько
        # вопросов (и только один ответ). В этом определении вопроса два.
        # Каждый начинается с `- line:`, очерёдность не важна, тк в конце
        # содержимое файлов всё равно будет перемешано.
        #
        # Первый вопрос с ます формой.
        - line: &masuL
          - vform: &masu
              base: "masuBased"
              # Функция, образующая формы, основанные на ます форме, убирает
              # ます, и нам его надо вернуть обратно.
              new:  "ます"
        # А второй вопрос со словарной формой, но тк мы её уже описали, то
        # здесь просто используем присвоенное выше имя.
        #
        # _Важно:_ раз этот блок начинается с `line`, то использовать надо
        # имя, присвоенное блоку с `line` (те, в данном случае, оканчивающееся
        # на букву `L`).
        - line: *dictL
      back:
        # Ответ здесь имеет несколько форм. Каждая форма в ответе начинается с
        # `- vform:`. Тк все их мы уже описали, то здесь просто используем
        # определённые выше имена.
        #
        # В свою очередь, здесь мы определим ещё одно новое имя - `futsuuL`,
        # которое соответствует блоку со всеми четырьмя формами ふつう形 .
        line: &futsuuL
          # _Важно:_ тк этот блок начинается с `vform`, то и имена надо
          # использовать, присвоенные блоку с `vfrom` (те _без_ буквы `L` на
          # конце).
          - vform: *dict
          - vform: *nai
          - vform: *ta
          - vform: *nakatta

# Определение файла, в котором в вопросе может быть любая из четырёх форм
# ふつう形, а в ответе всегда будут все четыре.
- name: "any_futsuu-futsuu"
  # Блок `files` определяет, где создавать файлы и сколько их создавать.
  files: &files
    # Папка, в которой создавать файлы. Значение по умолчанию - создать папку
    # `vforms` в текущей папке, те то, что сейчас, поэтому, если значение по
    # умолчанию подходит, его можно не указывать.
    #
    # _Важно:_ Здесь назначается папка только для конкретного определения
    # файла (те только для этого блока, начинающегося с `- name:`). Если нужно
    # создавать все файлы в другой папке, то определение `files` придётся
    # повторить для всех остальных определений файлов тоже.
    #
    # _Важно:_ Если нужно повторять этот блок в других определениях файлов,
    # можно ему присвоить имя (здесь - `files`) и использовать его в
    # остальных: `files: *files`, - но имя можно использовать _только_ ниже
    # его определения (те буквально только ниже строки с `&files`).
    dest: "./vforms"
    # Количество файлов, которые создавать.
    number: 3
  questions:
    # Тк ответ у нас один, то мы можем написать это в одной паре вопрос-ответ.
    - front:
        # У нас четыре разных вопроса, те должно быть четыре строчки,
        # начинающихся с `- line:`. Тк определения для всех форм уже были даны
        # выше, то снова просто используем имена. Тк строчки начинаются с
        # `line`, то и имена используем те, что заканчиваются на `L`.
        - line: *dictL
        - line: *naiL
        - line: *taL
        - line: *nakattaL
      # В ответе у нас все 4-е формы, те в точности то, что было в определении
      # `masu_dict-futsuu` выше, поэтому просто используем определённое там
      # имя.
      back:
        line: *futsuuL

# В этом файле ない-форма в вопросе соответствует た-форме в ответе, た в
# вопросе - なかった в ответе, и なかった в вопросе - словарной форме в
# ответе.
- name: "cross"
  # Путь и количество файлов такое же, как было определено выше в блоке
  # `files: &files`.
  files: *files
  # Для всех определений можно указать из каких уроков брать глаголы.  Если
  # `filter` не указан, то генерируются файлы со _всеми_ глаголами из таблицы
  # глаголов.  Если фильтр указан, то будут использоваться только глаголы из
  # соответствующих уроков. Любое из полей можно пропустить: те указать только
  # `from` или только `till`.
  #
  # _Важно:_ фильтр `from: 0` совпадает только с глаголами, для которых
  # _определён_ номер урока (любой, тк любой номер > 0). Те это _не то же
  # самое_, что не писать фильтр вообще (потому что не у всех глаголов в
  # таблице глаголов определён номер урока).
  filter:
    # Номер урока, начиная с которого (больше или равно) брать глаголы.
    from: 21
    # Номер урока, до которого (меньше или равно) брать глаголы.
    #
    # Те текущий фильтр совпадёт с глаголами из 21-25 уроков, фильтр `from:
    # 20` и `till: 20` совпадёт только с 20 уроком, а `from: 20` и `till: 19`
    # - ни с одним.
    till: 25
  questions:
    - front:
        - line: *naiL
      back:
        line: *taL
    - front:
        - line: *taL
      back:
        line: *nakattaL
    - front:
        - line: *nakattaL
      back:
        line: *dictL

